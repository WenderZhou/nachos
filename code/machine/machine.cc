// machine.cc 
//	Routines for simulating the execution of user programs.
//
//  DO NOT CHANGE -- part of the machine emulation
//
// Copyright (c) 1992-1993 The Regents of the University of California.
// All rights reserved.  See copyright.h for copyright notice and limitation 
// of liability and disclaimer of warranty provisions.

#include "copyright.h"
#include "machine.h"
#include "system.h"
#include "noff.h"

// Textual names of the exceptions that can be generated by user program
// execution, for debugging.
static char* exceptionNames[] = { "no exception", "syscall", 
				"page fault/no TLB entry", "page read only",
				"bus error", "address error", "overflow",
				"illegal instruction" };

//----------------------------------------------------------------------
// CheckEndian
// 	Check to be sure that the host really uses the format it says it 
//	does, for storing the bytes of an integer.  Stop on error.
//----------------------------------------------------------------------

static
void CheckEndian()
{
    union checkit {
        char charword[4];
        unsigned int intword;
    } check;

    check.charword[0] = 1;
    check.charword[1] = 2;
    check.charword[2] = 3;
    check.charword[3] = 4;

#ifdef HOST_IS_BIG_ENDIAN
    ASSERT (check.intword == 0x01020304);
#else
    ASSERT (check.intword == 0x04030201);
#endif
}

//----------------------------------------------------------------------
// Machine::Machine
// 	Initialize the simulation of user program execution.
//
//	"debug" -- if TRUE, drop into the debugger after each user instruction
//		is executed.
//----------------------------------------------------------------------

Machine::Machine(bool debug)
{
    int i;

    for (i = 0; i < NumTotalRegs; i++)
        registers[i] = 0;
    mainMemory = new char[MemorySize];
    for (i = 0; i < MemorySize; i++)
      	mainMemory[i] = 0;
#ifdef USE_TLB
    tlb = new TLB(TLBSize, TLBStrategy);
    pageTable = NULL;
#else	// use linear page table
    tlb = NULL;
    pageTable = NULL;
#endif

#ifdef INVERTED_PAGETABLE
    ipt = new InvertedPageTableEntry[NumPhysPages];
    for(int i = 0; i < NumPhysPages; ++i)
    {
        ipt[i].physicalPage = i;
        ipt[i].valid = false;
    }
#endif

    memBitMap = new BitMap(NumPhysPages);

#ifdef USE_SWAPSPACE
    swapSpace = new SwapSpace();
    swapPosition = 0;
#endif

    for(i = 0; i < NumPhysPages; i++)
        pageOwner[i] = NULL;

    singleStep = debug;
    CheckEndian();
}

//----------------------------------------------------------------------
// Machine::~Machine
// 	De-allocate the data structures used to simulate user program execution.
//----------------------------------------------------------------------

Machine::~Machine()
{
    delete [] mainMemory;
    delete memBitMap;

#ifdef USE_TLB
    delete tlb;
#endif

#ifdef USE_SWAPSPACE
    delete swapSpace;
#endif
}

//----------------------------------------------------------------------
// Machine::RaiseException
// 	Transfer control to the Nachos kernel from user mode, because
//	the user program either invoked a system call, or some exception
//	occured (such as the address translation failed).
//
//	"which" -- the cause of the kernel trap
//	"badVaddr" -- the virtual address causing the trap, if appropriate
//----------------------------------------------------------------------

void
Machine::RaiseException(ExceptionType which, int badVAddr)
{
    DEBUG('m', "Exception: %s\n", exceptionNames[which]);
    
//  ASSERT(interrupt->getStatus() == UserMode);
    registers[BadVAddrReg] = badVAddr;
    DelayedLoad(0, 0);			// finish anything in progress
    interrupt->setStatus(SystemMode);
    ExceptionHandler(which);		// interrupts are enabled at this point
    interrupt->setStatus(UserMode);
}

//----------------------------------------------------------------------
// Machine::Debugger
// 	Primitive debugger for user programs.  Note that we can't use
//	gdb to debug user programs, since gdb doesn't run on top of Nachos.
//	It could, but you'd have to implement *a lot* more system calls
//	to get it to work!
//
//	So just allow single-stepping, and printing the contents of memory.
//----------------------------------------------------------------------

void Machine::Debugger()
{
    char *buf = new char[80];
    int num;

    interrupt->DumpState();
    DumpState();
    printf("%d> ", stats->totalTicks);
    fflush(stdout);
    fgets(buf, 80, stdin);
    if (sscanf(buf, "%d", &num) == 1)
	runUntilTime = num;
    else {
	runUntilTime = 0;
	switch (*buf) {
	  case '\n':
	    break;
	    
	  case 'c':
	    singleStep = FALSE;
	    break;
	    
	  case '?':
	    printf("Machine commands:\n");
	    printf("    <return>  execute one instruction\n");
	    printf("    <number>  run until the given timer tick\n");
	    printf("    c         run until completion\n");
	    printf("    ?         print help message\n");
	    break;
	}
    }
    delete [] buf;
}
 
//----------------------------------------------------------------------
// Machine::DumpState
// 	Print the user program's CPU state.  We might print the contents
//	of memory, but that seemed like overkill.
//----------------------------------------------------------------------

void
Machine::DumpState()
{
    int i;
    
    printf("Machine registers:\n");
    for (i = 0; i < NumGPRegs; i++)
	switch (i) {
	  case StackReg:
	    printf("\tSP(%d):\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	    
	  case RetAddrReg:
	    printf("\tRA(%d):\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	  
	  default:
	    printf("\t%d:\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	}
    
    printf("\tHi:\t0x%x", registers[HiReg]);
    printf("\tLo:\t0x%x\n", registers[LoReg]);
    printf("\tPC:\t0x%x", registers[PCReg]);
    printf("\tNextPC:\t0x%x", registers[NextPCReg]);
    printf("\tPrevPC:\t0x%x\n", registers[PrevPCReg]);
    printf("\tLoad:\t0x%x", registers[LoadReg]);
    printf("\tLoadV:\t0x%x\n", registers[LoadValueReg]);
    printf("\n");
}

//----------------------------------------------------------------------
// Machine::ReadRegister/WriteRegister
//   	Fetch or write the contents of a user program register.
//----------------------------------------------------------------------

int Machine::ReadRegister(int num)
{
	ASSERT((num >= 0) && (num < NumTotalRegs));
	return registers[num];
}

void Machine::WriteRegister(int num, int value)
{
	ASSERT((num >= 0) && (num < NumTotalRegs));
	// DEBUG('m', "WriteRegister %d, value %d\n", num, value);
	registers[num] = value;
}

void Machine::MemRecycle()
{
#ifdef INVERTED_PAGETABLE
    for(int i = 0; i < NumPhysPages; ++i)
        if(ipt[i].valid && ipt[i].owner == currentThread)
        {
            memBitMap->Clear(i);
            printf("Recycle %d in main memory page %d\n",ipt[i].virtualPage,i);
        }
#else
    for(int i = 0; i < pageTableSize; ++i)
    {
        if(pageTable[i].valid)  // in memory
        {
            int pageFrame = pageTable[i].physicalPage;
            memBitMap->Clear(pageFrame);
            printf("Recycle %d in main memory page %d\n",i,pageFrame);
        }
    #ifdef USE_SWAPSPACE
        else if(pageTable[i].swapPage != -1)    // in swap space
        {
            swapSpace->Clear(pageTable[i].swapPage);
            printf("Recycle %d in swap space page %d\n",i,pageTable[i].swapPage);
        }
    #endif
    }
#endif
}

#ifdef INVERTED_PAGETABLE
void Machine::pageFaultHandler(int virtualPage)
{
    int page = memBitMap->Find();
    ASSERT(page != -1);
    char *filename = currentThread->space->getFileName();
    OpenFile *executable = fileSystem->Open(filename);
    executable->ReadAt(&mainMemory[page * PageSize], PageSize,
                        virtualPage * PageSize + sizeof(NoffHeader));
    delete executable;
    ipt[page].virtualPage = virtualPage;
    ipt[page].valid = true;
    ipt[page].owner = currentThread;
    ipt[page].use = false;
    ipt[page].dirty = false;
    ipt[page].readOnly = false;
}
#elif defined USE_SWAPSPACE
void Machine::pageFaultHandler(int virtualPage)
{
    int page = memBitMap->Find();
    
    // can not find an empty page in memory, create an empty page
    // by swap one page to swap space(dirty) or simply discard it(clean)
    if(page == -1)
    {
        // find a proper page, get the page's owner thread,
        // page table of the thread, and the virtual page number
        // of the page
        page = swapPosition;
        swapPosition = (swapPosition + 1) % NumPhysPages;
        
        Thread *swapThread = pageOwner[page];
        AddrSpace *space = swapThread->space;
        TranslationEntry *swapPageTable = space->getPageTable();
        int swapVpn = space->ppn2vpn(page);
        ASSERT(swapVpn != -1);

        // write back the tlb entry
#ifdef USE_TLB
        if(swapThread == currentThread)
            tlb->writeBack(swapVpn);
#endif

        // if the page has been modified, swap it to swap space
        if(swapPageTable[swapVpn].dirty)
        {
            int swapPage = swapSpace->SwapIn(page);
            swapPageTable[swapVpn].swapPage = swapPage;
            ASSERT(swapPage != -1);
#ifdef SHOW_INFO
            printf("store physical page %d to swap space page %d\n", page, swapPage);
#endif
        }

        swapPageTable[swapVpn].valid = false;
    }

    // load the page
    if(pageTable[virtualPage].dirty)    // from swap space
    {
        int swapPage = pageTable[virtualPage].swapPage;
        swapSpace->SwapOut(page,swapPage);
#ifdef SHOW_INFO
        printf("load from swap space page %d\n", swapPage);
#endif
    }
    else    // from its original file
    {
        char *filename = currentThread->space->getFileName();
        OpenFile *executable = fileSystem->Open(filename);
        executable->ReadAt(&mainMemory[page * PageSize], PageSize,
                            virtualPage * PageSize + sizeof(NoffHeader));
        delete executable;
#ifdef SHOW_INFO
        printf("load from executable file\n");
#endif
    }
    
    // modify the info of the entry
    pageTable[virtualPage].physicalPage = page;
    pageTable[virtualPage].swapPage = -1;
    pageTable[virtualPage].valid = true;

    pageOwner[page] = currentThread;

#ifdef SHOW_INFO
    printf("virtual page %d now in physical page %d\n",virtualPage,page);
#endif
}
#else
void Machine::pageFaultHandler(int virtualPage)
{
    // do nothing, this is a default version so that filesys can work
}
#endif